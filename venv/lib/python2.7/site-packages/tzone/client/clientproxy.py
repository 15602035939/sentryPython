#!/usr/bin/env python
# encoding: utf-8
import sys
import os
import socket

import opentracing
from opentracing.ext import tags as otags
from thrift.Thrift import TException, TApplicationException
from thrift.protocol.TMultiplexedProtocol import TMultiplexedProtocol
from thrift.transport.TTransport import TBufferedTransport, TTransportException
from thrift_json import dict2thrift
from tracing import tags as ttags
from tracing.request_context import get_current_span, RequestContextManager

from .exceptions import TimeoutError, RemoteServerError, TransportException
from .patch import TBinaryProtocolAccelerated
from .THttpClient import THttpClient
from .validator import validate

try:
    from tracing.constants import HTTP_HEADER_SERVER_INFO
    from tracing.util import parse_server_info
    TRACING_SUPPORT_VERSION_INFO = True
except ImportError:
    TRACING_SUPPORT_VERSION_INFO = False


class ClientProxy(object):
    def __init__(self, service, discover, timeout, strict):
        self._service = service
        self._service_name = service.__name__.split('.')[-1]
        self._discover = discover
        self._target_name = discover.target_name
        self._timeout = timeout
        self._strict = strict

    def _set_headers(self, http_client, method):
        headers = {
            'X-ZONE-API': '{0}.{1}'.format(self._service_name, method),
            'X-ZONE-ORIGIN': os.environ.get('ZHIHU_UNIT_NAME', 'unknown'),
            'X-ZONE-ORIGIN-APP': os.environ.get('ZHIHU_APP_NAME', 'unknown'),
            'X-ZONE-ORIGIN-UNIT': os.environ.get('ZHIHU_UNIT_NAME', 'unknown'),
        }
        # tracing
        span = get_current_span()
        if span:
            opentracing.tracer.inject(span=span,
                                      format=opentracing.Format.TEXT_MAP,
                                      carrier=headers)
        http_client.setCustomHeaders(headers)

    def __getattr__(self, method):

        def wrapper(*args, **kwargs):
            # automatically convert dict to struct
            method_args = getattr(self._service, method + '_args')
            args = list(args)
            for index in range(len(args)):
                if isinstance(args[index], dict):
                    field = method_args.thrift_spec[index + 1]
                    (tag, field_ttype, field_name, field_ttype_info, dummy) = field
                    thrift_class = field_ttype_info[0]
                    args[index] = dict2thrift(args[index], thrift_class)

            # validate arguements
            if self._strict:
                validate(args)
                validate(kwargs.values())

            full_method = "%s_%s" % (self._service_name, method)
            parent_span = get_current_span()
            tags = {
                otags.SPAN_KIND: otags.SPAN_KIND_RPC_CLIENT,
                otags.PEER_SERVICE: self._target_name or 'unknown',
            }

            exception = None
            with opentracing.tracer.start_span(full_method, parent_span, tags) as span:
                with RequestContextManager(span):
                    host, port = self._discover.get_address()
                    url = "http://{0}:{1}".format(host, port)
                    http_client = THttpClient(url)
                    http_client.setTimeout(kwargs.pop('_timeout', self._timeout) * 1000)
                    transport = TBufferedTransport(http_client)
                    protocol = TBinaryProtocolAccelerated(transport)
                    mp = TMultiplexedProtocol(protocol, self._service_name)
                    client = self._service.Client(protocol, mp)
                    self._set_headers(http_client, method)
                    try:
                        meth = getattr(client, method)
                        ret = meth(*args, **kwargs)
                        if TRACING_SUPPORT_VERSION_INFO:
                            for header, value in http_client.headers:
                                if header != HTTP_HEADER_SERVER_INFO.lower():
                                    continue
                                app, unit, version = parse_server_info(value)
                                span.set_tag(ttags.PEER_VERSION, version)
                                break
                        return ret
                    except TApplicationException:
                        raise
                    except TTransportException as e:
                        self._discover.discard((host, port))
                        exc_type, exc_value, exc_tb = sys.exc_info()
                        raise TransportException, exc_value, exc_tb
                    # 除了 TApplicationException, TransportException 外的 TException 视为正常
                    # 这里捕获后, 不会被 span.__exit__ 视为错误
                    except TException as e:
                        exception = e
                    except EOFError:
                        self._discover.discard((host, port))
                        raise RemoteServerError(code=http_client.code,
                                                message=http_client.response.reason
                                                )
                    except socket.timeout:
                        exc_type, exc_value, exc_tb = sys.exc_info()
                        raise TimeoutError, exc_value, exc_tb
                    finally:
                        if transport.isOpen():
                            transport.close()
            if exception:
                raise exception

        return wrapper
