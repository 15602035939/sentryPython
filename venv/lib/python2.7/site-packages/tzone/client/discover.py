#!/usr/bin/env python
# encoding: utf-8
import logging
import random
import time

from diplomat import discover
from .exceptions import ConnectionError

logger = logging.getLogger("tzone.client")


class Discoverer(object):
    """Discoverer for target app address, with load balancing and fail over.

    1. The discoverer will refresh the service list every 10 seconds by
       default. The selection strategy is roundrobin, for keeping the
       connections balanced.
    2. Once a connection to a specified host failed, discard the host and
       try the next. And loop the process until find a connectable host
       or the retry time reaches the max time. If all the hosts are
       discarded, refresh the host list.
    3. The discoverer also accepts an extra address pair, for fallback
       when the discovery agent is down. If no backup address found, zone
       will try to pick one from the discarded addresses.
    """

    def __init__(self, target_name=None, host=None, port=None, ttl=10):
        self.target_name = target_name
        self.host = host
        self.port = port
        self.ttl = ttl
        self._diplomat = discover(driver='std')
        self._discarded_addresses = set()
        self._last_cleanup_time = None

    def get_address(self):
        """Try hard to get an usable address.

        :returns: IP-port pair of the target server.
        """
        target_name = self.target_name
        host = self.host
        port = self.port

        if not target_name:
            if not host and not port:
                raise ConnectionError('No address available.')
            return host, port

        self._cleanup()

        discarded_addresses = self._discarded_addresses
        diplomat = self._diplomat

        max_rr_time = len(discarded_addresses) + 1
        rr_time = 0
        address = None

        try:
            while True:
                address_info = diplomat.select(target_name,
                                               strategy='roundrobin')
                if not address_info:
                    raise ConnectionError('No address available.')
                address = (address_info['address'], address_info['port'])
                if address not in discarded_addresses:
                    break

                rr_time += 1
                if rr_time == max_rr_time:
                    if host and port:
                        logger.warn('No healthy addresses available, '
                                    'fallback to the given host-port pair.')
                        address = (host, port)
                    elif discarded_addresses:
                        address = random.sample(discarded_addresses, 1)[0]
                        logger.warn('Fallback to a discarded address: %s' % str(address))
                    else:
                        raise ConnectionError(
                            'Iterated on all the addresses, '
                            'no healthy address available.')
                    break
        except ConnectionError:
            raise
        except Exception as e:
            # Failed to discover target address, fallback to the
            # given address if available.
            logger.exception(e)
            if not host and not port:
                raise
            return host, port

        return address

    def discard(self, address):
        """Discard the given address for a period. The TTL is the one passed
        in the initializer."""
        if not self._last_cleanup_time:
            self._last_cleanup_time = time.time()
        if address not in self._discarded_addresses:
            self._discarded_addresses.add(address)
        else:
            return False
        return True

    def _cleanup(self):
        """Cleanup the discarded addresses, the expiration time is the TTL."""
        now = time.time()
        if self._last_cleanup_time:
            if self._last_cleanup_time + self.ttl <= now:
                self._discarded_addresses = set()
                self._last_cleanup_time = now
        else:
            self._last_cleanup_time = now
