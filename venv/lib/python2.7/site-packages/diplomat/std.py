#!/usr/bin/env python
# encoding: utf-8
import os
import random
from collections import Counter

import requests
from consul import std
from tlcache import TLCache

from diplomat import __version__

__all__ = ['Diplomat']

cache = TLCache("/tmp/consul{0}".format(__version__))


class Diplomat(std.Consul):
    def __init__(self, *args, **kwargs):
        """
        Std diplomat driver. Since it can't auto clear, given the
        cache with a expire timeout.

        It provides following extra param besides of ``python-consul``.

        :param ttl: ttl time of the cache
        """
        super(Diplomat, self).__init__(*args, **kwargs)
        adapter = requests.adapters.HTTPAdapter(max_retries=3)
        self.http.session.mount("http://", adapter)
        self.http.session.mount("https://", adapter)
        self.request_ids = Counter()

    @cache.cache(timeout=30)
    def _health(self, name, passing, tag, dc, consistency, timeout):
        params = {}
        if passing:
            params['passing'] = '1'
        if tag is not None:
            params['tag'] = tag
        dc = dc or self.dc
        if dc:
            params['dc'] = dc
        if consistency in ('consistent', 'stale'):
            params[consistency] = '1'
        uri = self.http.uri('/v1/health/service/%s' % name, params)
        nodes = self.http.session.get(uri, verify=self.http.verify, timeout=timeout).json()
        services = [{'node': node['Node']['Node'],
                     'address': node['Service']['Address'] or node['Node']['Address'],
                     'id': node['Service']['ID'],
                     'service': node['Service']['Service'],
                     'port': node['Service']['Port'],
                     'tags': node['Service']['Tags'],
                     'checks': node['Checks']} for node in nodes]
        return services

    def find(self, name, passing=True, tag=None, dc=None, consistency='stale', timeout=(0.1, 0.2), refresh=False):
        """
        :param name: The name of the service
        :param passing: True will filter results to only
         those nodes whose checks are currently passing
        :param tag: If set, results will filter by tag
        :param dc: is the datacenter of the node and defaults to this agents
         datacenter.
        :returns: Return a list of service
        """
        env_address = os.getenv('{0}_SERVICE_ADDRESS'.format(
            name.upper().replace('-', '_').replace('.', '_')
        ))
        if env_address:
            _host, _port = env_address.split(':')
            return [{
                'address': _host,
                'port': int(_port),
            }]
        if refresh:
            with cache.with_refresh():
                return self._health(name, passing=passing, tag=tag, dc=dc, consistency=consistency, timeout=timeout)
        else:
            return self._health(name, passing=passing, tag=tag, dc=dc, consistency=consistency, timeout=timeout)

    def select(self, name, passing=True, tag=None, dc=None, consistency='stale', strategy='random', refresh=False):
        """
        :param name: The name of the service
        :param passing: True will filter results to only
         those nodes whose checks are currently passing
        :param tag: If set, results will filter by tag
        :param dc: is the datacenter of the node and defaults to this agents
         datacenter.
        :returns: Return a service
        """
        services = self.find(name, passing, tag, dc, consistency=consistency, refresh=refresh)
        if not services:
            return None
        if strategy == 'random':
            return random.choice(services)
        else:
            self.request_ids[name] += 1
            no = self.request_ids[name] % len(services)
            return services[no]
