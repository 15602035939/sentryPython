#!/usr/bin/env python
# coding: utf-8


import json
import logging
import sys
import time
import weakref

import opentracing
import six
from opentracing.ext import tags as otags

from tracing import event_types
from tracing import tags as ttags
from tracing import util
from tracing.annotation import Annotation, BinaryAnnotation
from tracing.constants import CLIENT_SEND, SERVER_RECV, SERVER_SEND, CLIENT_RECV
from tracing.endpoint import Endpoint, resolve
from tracing.exceptions import TracingException
from tracing.exceptions import get_exception_name
from tracing.gen_thrift.zipkinCore import ttypes
from tracing.stack_trace import exception_stack
from tracing.statsd import StatsCollection
from tracing.util import micro_time, to_signed

_logger = logging.getLogger(__name__)
_special_tags = [otags.SPAN_KIND, otags.PEER_SERVICE]
_special_events = [CLIENT_SEND, SERVER_RECV, SERVER_SEND, CLIENT_RECV]


def _to_zipkin_binary_annotation(key, value):
    if isinstance(value, unicode) or key == "traceback":
        value = value.encode('utf-8')
        annotation_type = ttypes.AnnotationType.BYTES
    else:
        value = str(value)
        annotation_type = ttypes.AnnotationType.STRING
    return BinaryAnnotation(key=key, value=value, annotation_type=annotation_type)


class Span(opentracing.Span):
    stats_collection = StatsCollection()

    def __init__(self, unit_name, version, operation_name, parent, tags,
                 start_time, trace_id, tracer):
        """
        :param unit_name: application unit name
        :param operation_name: name of the operation represented by the new
            span from the perspective of the current service.
        :param parent: parent span, or None if this is a root span
        :param tags:  Dictionary of Span Tags. Must specify the following tags
          opentracing.ext.tags.SPAN_KIND
        :param trace_id: instance of TraceId, span id

        Client side span must specify peer service once we know. Set it via
        ``set_tag(tags.PEER_SERVICE)``
        """
        self.unit_name = unit_name
        self.name = operation_name
        self.version = version
        self.tags = tags
        self.start_time = start_time
        self.end_time = None
        self.trace_id = trace_id
        self._tracer = tracer
        self.is_success = None
        self._server_span_instance = None
        if not self.is_server and parent is not None:
            if parent._server_span:
                self._server_span_instance = weakref.ref(parent._server_span)
        self.annotations = []

        self._new_metric = version is not None
        self._start()

    @property
    def _server_span(self):
        if self.is_server:
            return self
        elif self._server_span_instance:
            return self._server_span_instance()
        return None

    def __repr__(self):
        return "Span<TraceId={!r}, Unit={}, Operation={}, Version={}, " \
               "Tags={}>".format(self.trace_id, self.unit_name, self.name,
                                 self.version, self.tags)

    @property
    def _is_active_sampling(self):
        orphan_span = self._server_span is None
        return self.trace_id.sampled and not orphan_span

    def _start(self):
        if self.start_time is None:
            self.start_time = time.time()
        if not self._is_active_sampling:
            return self
        if self._is_client:
            container_group = Endpoint.container_group()
            if container_group:
                self.set_tag(ttags.CLIENT_CONTAINER_GROUP, container_group)
            self.log(event=CLIENT_SEND, timestamp=self.start_time)
        elif self.is_server:
            self.set_tag(ttags.PEER_VERSION, self.version)
            container_group = Endpoint.container_group()
            if container_group:
                self.set_tag(ttags.SERVER_CONTAINER_GROUP, container_group)
            self.log(event=SERVER_RECV, timestamp=self.start_time)
        return self

    @staticmethod
    def _record_with_prefix(prefix, latency, is_success, error_name):
        Span.stats_collection.incr(prefix + ".count")
        if is_success:
            Span.stats_collection.timing(prefix + ".request_time", latency)
        else:
            Span.stats_collection.incr("%s.error.%s.count" % (prefix, error_name))

    def _record_metric(self, is_success, exception_name_norm):
        duration = self.end_time - self.start_time
        if self._is_client:
            self.log(event=CLIENT_RECV, timestamp=self.end_time)
            if self._server_span is not None:
                prefix_merged = "span.{}._all.client.{}.{}._all.{}".format(
                    self.unit_name, self._server_span.name,
                    self._service_name, self.name)
                self._record_with_prefix(prefix_merged, duration, is_success,
                                         exception_name_norm)
                prefix = "span.{}.{}.client.{}.{}.{}.{}".format(
                    self.unit_name, self.version, self._server_span.name,
                    self._service_name, self._service_version, self.name)
                self._record_with_prefix(prefix, duration, is_success,
                                         exception_name_norm)
        elif self.is_server:
            prefix_merged = "span.{}._all.server.{}".format(
                self.unit_name, self.name)
            self._record_with_prefix(prefix_merged, duration, is_success,
                                     exception_name_norm)
            prefix = "span.{}.{}.server.{}".format(
                self.unit_name, self.version, self.name)
            self._record_with_prefix(prefix, duration, is_success,
                                     exception_name_norm)
            self.log(event=SERVER_SEND, timestamp=self.end_time)
        elif self._is_local:
            prefix_merged = "span.{}._all.client.{}.local_{}.{}".format(
                self.unit_name, self._server_span.name, self._category,
                self.name)
            self._record_with_prefix(prefix_merged, duration, is_success,
                                     exception_name_norm)
            prefix = "span.{}.{}.client.{}.local_{}.{}".format(
                self.unit_name, self.version, self._server_span.name,
                self._category, self.name)
            self._record_with_prefix(prefix, duration, is_success,
                                     exception_name_norm)

    def _end(self, exc=None, value=None, tb=None):
        if self.end_time is None:
            self.end_time = time.time()
        is_success = exc is None or value is None or tb is None
        self.is_success = is_success

        exception_name = get_exception_name(value)
        exception_name_norm = exception_name.replace(".", "-").replace(":", "-")
        if not is_success and self._is_active_sampling:
            # no need to find success spans, so only record error
            self._record_failed(exception_name)
            if self.is_server:
                self.set_tag(event_types.ERROR, exception_name)
        with Span.stats_collection.lock:
            self._record_metric(is_success, exception_name_norm)
        self._tracer.end(self)

    def __enter__(self):
        return self

    def __exit__(self, exc=None, value=None, tb=None):
        self._end(exc, value, tb)

    def finish(self, finish_time=None):
        """Do not call this directly.

        Use span as context manager or call __exit__  explicitly so that failed span is logged.

        This API is only used for specifying end time.
        """
        self.end_time = finish_time
        self._end()

    def log(self, **kwargs):
        """Records a generic Log event at an arbitrary timestamp.
        :param timestamp: the log timestamp as a unix timestamp per time.time()
        :param event: an event type as a string
        :param payload: additional key, value pair attributes dictionary.
        :return: returns the span itself, for chaining the calls
        """
        if not self._is_active_sampling:
            return self
        event = kwargs["event"]
        payload = kwargs.get("payload", None)
        timestamp = kwargs.get("timestamp", None) or time.time()
        if event in _special_events:
            self.annotations.append(Annotation(micro_time(timestamp), event))
            return self

        # Todokanai, for now.
        # if payload and not isinstance(payload, dict):
        #     msg = "unexpected payload %s, expect dict" % payload
        #     raise Exception(msg)
        # msg = {
        #     "type": event,
        # }
        # if event == event_types.EXCEPTION:
        #     # record exception as binary annotation so that it is not indexed.
        #     exc, value, tb = payload.pop("type", None), payload.pop("val", None), payload.pop("tb", None)
        #     if exc is None or value is None or tb is None:
        #         exc, value, tb = sys.exc_info()
        #     msg["name"] = get_exception_name(value)
        #     formatted_tb = exception_stack(exc, value, tb)
        #     msg["traceback"] = "".join(formatted_tb)
        #     if len(payload) > 0:
        #         msg["params"] = payload
        #     encoded = util.encode(msg)
        #     # only server exception will be recorded
        #     self.set_tag("traceback", encoded)
        #     return self
        # msg["payload"] = payload
        # encoded = util.encode(msg)
        # self.annotations.append(Annotation(micro_time(timestamp), encoded))
        return self

    def log_event(self, event, payload=None):
        """Logs an event against the span, with the current timestamp.
        :param event: an event type as a string
        :param payload: additional key, value pair attributes dictionary.
        when event is `exception` , can pass special key `type`, `val`, `tb`, so that traceback will
        be extracted and sent out.
        :return: returns the span itself, for chaining the calls
        """
        return self.log(event=event, payload=payload)

    def set_tag(self, key, value):
        """
        :param key: key or name of the tag. Must be a string.
        :param value: value of the tag.
        :return: Returns the Span itself, for call chaining.
        """
        if key == otags.SPAN_KIND:
            raise TracingException("can not change span kind")
        self.tags[key] = value
        return self

    def set_operation_name(self, operation_name):
        self.name = operation_name
        return self

    @property
    def _service_name(self):
        if self.is_server or self._is_local:
            return self.unit_name
        service = self.tags.get(otags.PEER_SERVICE, None)
        if service is None:
            return "unknown"
        else:
            return service

    @property
    def _service_version(self):
        if self.is_server or self._is_local:
            return self.version

        version = self.tags.get(ttags.PEER_VERSION, None)
        if version is None:
            return "unknown"
        else:
            return version

    def _record_failed(self, exception_name):
        if self._is_client:
            self.set_tag(ttags.SPAN_CLIENT_ERROR, exception_name)
        elif self.is_server:
            self.set_tag(ttags.SPAN_SERVER_ERROR, exception_name)
        else:
            self.set_tag(ttags.SPAN_LOCAL_ERROR, exception_name)

    def set_sampled(self, sampled):
        self.trace_id = self.trace_id._replace(sampled=sampled)
        return self

    @property
    def _is_client(self):
        return self.tags[otags.SPAN_KIND] == otags.SPAN_KIND_RPC_CLIENT

    @property
    def is_server(self):
        return self.tags[otags.SPAN_KIND] == otags.SPAN_KIND_RPC_SERVER

    @property
    def _is_local(self):
        return self.tags[otags.SPAN_KIND] == ttags.SPAN_KIND_LOCAL

    @property
    def _category(self):
        if self._is_local:
            return self.tags[ttags.SPAN_KIND_LOCAL]

    def to_json(self):
        """serialize span to json.

        Field name is set to work with zipkin_transfer.
        """
        json_span = {
            "TraceId": self.trace_id.trace_id,
            "Id": self.trace_id.span_id,
            "Name": self.name,
            "Annotations": [],
            "BinaryAnnotations": [],
        }
        if self.trace_id.parent_id:
            json_span["ParentId"] = self.trace_id.parent_id

        service_recorded = False
        for annotation in self.annotations:
            json_annotation = {
                "Timestamp": annotation.timestamp,
                "Value": annotation.value,
            }

            if not service_recorded:
                json_annotation["Host"] = {
                    "ServiceName": self._service_name
                }
                service_recorded = True
            json_span["Annotations"].append(json_annotation)
        for key, value in six.iteritems(self.tags):
            if key in _special_tags:
                continue
            annotation = _to_zipkin_binary_annotation(key, value)
            json_annotation = {
                "Key": annotation.key,
                "Value": str(annotation.value),
                "AnnotationType": annotation.annotation_type,
            }
            json_span["BinaryAnnotations"].append(json_annotation)
        return json.dumps(json_span)

    def to_thrift(self):
        annotations = []
        binary_annotations = []
        for annotation in self.annotations:
            thrift_annotation = ttypes.Annotation(
                timestamp=annotation.timestamp,
                value=annotation.value,
                host=ttypes.Endpoint(ipv4=Endpoint.local_ip(),
                                     service_name=self._service_name))
            annotations.append(thrift_annotation)

        for key, value in six.iteritems(self.tags):
            if key in _special_tags:
                continue

            annotation = _to_zipkin_binary_annotation(key, value)
            ipv4 = Endpoint.local_ip()
            port = 0
            if key == 'sa' or key == 'ca':
                host, port = value.rsplit(":", 1)
                port = int(port)
                ip = resolve(host)
                if ip is not None:
                    ipv4 = ip
            binary_annotations.append(ttypes.BinaryAnnotation(
                key=annotation.key,
                value=annotation.value,
                annotation_type=annotation.annotation_type,
                host=ttypes.Endpoint(ipv4=ipv4,
                                     port=port,
                                     service_name=self._service_name)
            ))
        thrift_span = ttypes.Span(
            timestamp=micro_time(self.start_time),
            duration=micro_time(self.end_time - self.start_time),
            trace_id=to_signed(self.trace_id.trace_id & 0xffffffffffffffff),
            name=self.name,
            id=to_signed(self.trace_id.span_id & 0xffffffffffffffff),
            parent_id=self.trace_id.parent_id and to_signed(
                self.trace_id.parent_id),
            annotations=annotations,
            binary_annotations=binary_annotations,
            trace_id_high=to_signed(self.trace_id.trace_id >> 64)
        )
        return thrift_span


def start_local_span(parent_span, category, name, tags=None, start_time=None):
    """Start a local span that happens in server process.

    :param parent_span: the server interface span
    :param category: namespace of the local span, for example, the class name
    :param name: name of the local span, for example, function name
    :param tags: optional dict of span tags. Provides additional context of the span. The caller
        gives up ownership of that dict, because the Tracer may use it as-is to avoid extra data
        copying.
    :param start_time: an explicit Span start time as a unix timestamp per time.time().
    :return: the span
    """
    if tags is None:
        tags = {}
    tags[otags.SPAN_KIND] = ttags.SPAN_KIND_LOCAL
    tags[ttags.SPAN_KIND_LOCAL] = category
    return parent_span.tracer.start_span(
        operation_name=name,
        parent=parent_span,
        tags=tags,
        start_time=start_time
    )
