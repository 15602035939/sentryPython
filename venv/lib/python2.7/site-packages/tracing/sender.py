#!/usr/bin/env python
# coding: utf-8

import errno
import logging
import socket
import threading

from kafka import KafkaProducer

from tracing.statsd import Statsd, StatsCollection
from tracing.reporter import Reporter

_logger = logging.getLogger(__name__)


class Sender(object):
    def write(self, spans):
        pass

    def flush(self):
        pass


class KafkaSender(Sender):
    def __init__(self, kafka_hosts, kafka_topic, codec):
        self.spans = []
        self.hosts = kafka_hosts
        self.topic = kafka_topic
        self.codec = codec
        self._producer = self._get_producer()
        self._lock = threading.Lock()

    def _get_producer(self):
        return KafkaProducer(bootstrap_servers=self.hosts)

    def write(self, spans):
        """Write span to buffer."""
        with self._lock:
            self.spans.extend(spans)
        Reporter.instance().wake_up()

    def flush(self):
        """Send metrics and traces to the wire, will block.

        called in reporter thread
        """
        with self._lock:
            spans = self.spans
            self.spans = []

        if len(spans) == 0:
            return

        stats = StatsCollection()
        try:
            with stats.time("tracing.internal.{}.sender.serialize_time".format(
                    Statsd.unit_name)):
                msgs = self.codec.encode(spans, stats)
            with stats.time("tracing.internal.{}.sender.send_time".format(
                    Statsd.unit_name)):
                self._producer.send(self.topic, *msgs)
                self._producer.flush()

            total_size = 0
            for msg in msgs:
                total_size += len(msg)
                stats.timing(
                    "tracing.internal.{}.sender.serialize_msg_size".format(
                        Statsd.unit_name),
                    len(msg) / 1000)

            stats.incr(
                "tracing.internal.{}.sender.serialize_span_count".format(
                    Statsd.unit_name),
                len(spans))
            stats.incr(
                "tracing.internal.{}.sender.serialize_msg_count".format(
                    Statsd.unit_name),
                len(msgs))
            stats.gauge(
                "tracing.internal.{}.sender.serialize_total_size".format(
                    Statsd.unit_name),
                total_size)
            Statsd.send_stats(stats)
        except Exception as e:
            stats.incr("tracing.internal.%s.sender.error.count".format(
                Statsd.unit_name))
            _logger.exception("error sending trace to kafka: %s", e)


class DatagramSender(Sender):
    def __init__(self, host, port, codec, sndbuf=4096):
        self.host = host
        self.port = port
        self.codec = codec
        self.sndbuf = sndbuf
        self.spans = []
        self._lock = threading.Lock()
        self.socket = self.get_socket()

    def get_socket(self):
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, self.sndbuf)
        s.connect((self.host, self.port))
        return s

    def _send(self, stats, data):
        for _ in range(2):
            try:
                self.socket.send(data)
                return
            except OSError as e:
                stats.incr("tracing.{}.sender.error.errno#{}.count"
                           .format(Statsd.unit_name, e.errno))
                if e.errno == errno.ENOTCONN:
                    self.socket.close()
                    self.socket = self.get_socket()
                else:
                    break

    def write(self, spans):
        with self._lock:
            self.spans.extend(spans)
        Reporter.instance().wake_up()

    def flush(self):
        with self._lock:
            spans = self.spans
            self.spans = []

        if len(spans) == 0:
            return

        stats = StatsCollection()
        try:
            with stats.time("tracing.internal.{}.sender.serialize_time".format(
                    Statsd.unit_name)):
                msgs = self.codec.encode(spans, stats)
            total_size = 0
            with stats.time("tracing.internal.{}.sender.send_time".format(
                    Statsd.unit_name)):
                for msg in msgs:
                    self._send(stats, msg)
                    total_size += len(msg)
                    stats.timing(
                        "tracing.internal.{}.sender.serialize_msg_size".format(
                            Statsd.unit_name),
                        len(msg) / 1000)
            stats.incr(
                "tracing.internal.{}.sender.serialize_span_count".format(
                    Statsd.unit_name),
                len(spans))
            stats.incr(
                "tracing.internal.{}.sender.serialize_msg_count".format(
                    Statsd.unit_name),
                len(msgs))
            stats.gauge(
                "tracing.internal.{}.sender.serialize_total_size".format(
                    Statsd.unit_name),
                total_size)
        except:
            stats.incr("tracing.internal.{}.sender.error.count".format(
                Statsd.unit_name))
        finally:
            Statsd.send_stats(stats)

