#!/usr/bin/env python
# coding: utf-8

"""
TODO:

* 统一的 StatsCollection 发送方式
* 去除各模块对 unit_name 的依赖
"""
import threading
from functools import wraps
import socket
import time

import six


class StatsCollection(object):
    def __init__(self):
        self._timers = {}
        self._counts = {}
        self._gauges = {}
        # caller should lock the region when calling incr, gauge, timing, etc.
        self.lock = threading.RLock()
        self._statsd_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    def __str__(self):
        return "StatsCollection<%s, %s, %s>" % (self._timers, self._counts, self._gauges)

    def incr(self, name, count=1):
        a = self._counts.setdefault(name, 0)
        self._counts[name] = a + count

    def gauge(self, name, value):
        self._gauges[name] = value

    def timing(self, name, value):
        """
        :param value: time in seconds, as returned by time.time()

        3.1234 will be sent to graphite as 3123 ms
        """
        a = self._timers.setdefault(name, [])
        a.append(value * 1000)

    def time(self, name):
        """Time a block of code or function, and observe the duration in milliseconds.
        Can be used as a function decorator or context manager.
        """

        return Timer(self, name)

    def get(self):
        with self.lock:
            timers, counts, gauges = self._timers, self._counts, self._gauges
            self._timers, self._counts, self._gauges = {}, {}, {}
        return timers, counts, gauges

    def merge(self, other):
        for k in other._timers:
            timer = self._timers.setdefault(k, [])
            timer.extend(other._timers[k])
        for k in other._counts:
            count = self._counts.get(k, 0)
            self._counts[k] = count + other._counts[k]
        for k in other._gauges:
            # other is more latest than current
            self._gauges[k] = other._gauges[k]


class StatsdClient(object):
    """
    StatsCollection collects all metrics.

    incr, timing, gauge of this client should only be used in main thread. Use StatsdCollection when in other thread.
    """
    def __init__(self):
        self._initialized = False
        self._statsd_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self._max_packet_size = 63000

    def initialize(self, app_name, unit_name, host, port):
        self._initialized = True
        self.host = host
        self.port = port
        self.app_name = app_name
        self.unit_name = unit_name
        self._refresh_addr()

    @staticmethod
    def _fmt_value(name, value, mtype):
        if int(value) == value:
            fmt = "%s:%d|%s"
        else:
            fmt = "%s:%.3f|%s"
        msg = fmt % (name, value, mtype)
        return msg

    def send_stats(self, stats_collection):
        """Send stats.

        This function is thread safe. Only used internally by tracing.
        """
        if not self._initialized:
            return
        if stats_collection._statsd_socket is None:
            stats_collection._statsd_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        send_socket = stats_collection._statsd_socket
        timers, counts, gauges = stats_collection.get()
        buf = []
        l = 0

        try:
            for name, points in six.iteritems(timers):
                for value in points:
                    msg = self._fmt_value(name, value, "ms")
                    l += len(msg) + 1
                    if l >= self._max_packet_size:
                        send_socket.sendto("\n".join(buf), self._addr)
                        buf = []
                        l = 0
                    buf.append(msg)

            for name, value in six.iteritems(counts):
                msg = self._fmt_value(name, value, "c")
                l += len(msg) + 1
                if l >= self._max_packet_size:
                    send_socket.sendto("\n".join(buf), self._addr)
                    buf = []
                    l = 0
                buf.append(msg)

            for name, value in six.iteritems(gauges):
                msg = self._fmt_value(name, value, "g")
                l += len(msg) + 1
                if l >= self._max_packet_size:
                    send_socket.sendto("\n".join(buf), self._addr)
                    buf = []
                    l = 0
                buf.append(msg)

            if len(buf) > 0:
                send_socket.sendto("\n".join(buf), self._addr)
        except socket.error:
            stats_collection._statsd_socket.close()
            stats_collection._statsd_socket = None
            self._refresh_addr()

    def _refresh_addr(self):
        family, _, _, _, addr = socket.getaddrinfo(
            self.host, self.port, socket.AF_INET, socket.SOCK_DGRAM)[0]
        self._addr = addr

    def _send(self, name, value, mtype):
        if not self._initialized:
            return
        msg = "tracing.custom.%s.%s:%s|%s" % (self.app_name, name, value, mtype)
        if self._statsd_socket is None:
            self._statsd_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            self._statsd_socket.sendto(msg, self._addr)
        except socket.error:
            self._statsd_socket.close()
            self._statsd_socket = None
            self._refresh_addr()

    def incr(self, name, count=1):
        if not name.endswith(".count"):
            name += ".count"
        self._send(name, count, "c")

    def timing(self, name, value):
        self._send(name, 1000*value, "ms")

    def gauge(self, name, value):
        self._send(name, value, "g")

    def time(self, name):
        """Time a block of code or function, and observe the duration in milliseconds.
        Can be used as a function decorator or context manager.
        """
        return Timer(self, name)


class Timer(object):
    def __init__(self, collection, name):
        self._collection = collection
        self._name = name

    def __enter__(self):
        self._start = time.time()

    def __exit__(self, typ, value, traceback):
        # Time can go backwards.
        self._collection.timing(self._name, max(time.time() - self._start, 0))

    def __call__(self, f):
        @wraps(f)
        def wrapped(*args, **kwargs):
            with self:
                return f(*args, **kwargs)
        return wrapped

Statsd = StatsdClient()
