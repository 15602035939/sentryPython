#!/usr/bin/env python
# coding: utf-8

from wrapt import FunctionWrapper
import opentracing
from opentracing.ext import tags as otags

from tracing import tags as ttags
from tracing.request_context import get_current_span

from tracing.hooks.utils.object_wrapper import wrap_object

collection_methods = (
    "bulk_write", "insert_one", "insert_many", "replace_one", "update_one", "update_many", "delete_one", "delete_many",
    "aggregate", "find", "find_one", "find_one_and_delete", "find_one_and_replace", "find_one_and_update", "count",
    "distinct", "create_index", "create_indexes", "drop_index", "drop_indexes", "reindex", "list_indexes", "index_information",
    "drop", "rename", "options", "group", "map_reduce", "inline_map_reduce", "parallel_scan", "initialize_unordered_bulk_op",
    "initialize_ordered_bulk_op"
)


def pymongo_wrapper(wrapped, operation):
    def _wrapper_pymongo_collection_methods(wrapped, instance, args, kwargs):
        # when mongo methods call each other, avoid recording twice.
        in_mongo_methods = getattr(instance, "_tc_in_mongo", None)
        if in_mongo_methods is not None:
            return wrapped(*args, **kwargs)
        instance._tc_in_mongo = True
        try:
            tags = {
                otags.SPAN_KIND: otags.SPAN_KIND_RPC_CLIENT,
                otags.PEER_SERVICE: "mongodb",
                ttags.MONGODB_COLLECTION: str(instance.name),
            }
            with opentracing.tracer.start_span(operation, get_current_span(), tags):
                return wrapped(*args, **kwargs)
        finally:
            instance._tc_in_mongo = None

    return FunctionWrapper(wrapped, _wrapper_pymongo_collection_methods)


def instrument_pymongo_collection(module):

    for name in collection_methods:
        if hasattr(module.Collection, name):
            wrap_object(module.Collection, name, pymongo_wrapper, (name,))
