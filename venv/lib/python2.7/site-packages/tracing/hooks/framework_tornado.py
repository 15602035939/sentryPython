#!/usr/bin/env python
# coding: utf-8
from wrapt.wrappers import wrap_function_wrapper

import opentracing
from opentracing.ext import tags as otags

from tracing import tags as ttags
from tracing.request_context import RequestContextManager
from tracing.constants import HTTP_HEADER_TRACE_ID

# a sensible placeholder, to be override when instrumentation happens
HTTPError = type('HTTPError', (Exception,), {})


def _wrapper_request_handler__init__(wrapped, instance, args, kwargs):
    def _arguments(application, request, *args, **kwargs):
        return request
    request = _arguments(*args, **kwargs)
    operation_name = "{}_{}".format(instance.__class__.__name__,
                                    request.method.lower())

    span = opentracing.tracer.join(
        operation_name=operation_name,
        format=opentracing.Format.TEXT_MAP,
        carrier=request.headers,
    )
    if span is None:
        tags = {
            otags.SPAN_KIND: otags.SPAN_KIND_RPC_SERVER,
        }
        if HTTP_HEADER_TRACE_ID in request.headers:
            tags[HTTP_HEADER_TRACE_ID] = request.headers[HTTP_HEADER_TRACE_ID]
        span = opentracing.tracer.start_span(
            operation_name=operation_name,
            tags=tags)
    span.set_tag(ttags.HTTP_HOST, request.host)
    span.set_tag(ttags.HTTP_METHOD, request.method)
    span.set_tag(ttags.HTTP_PATH, request.path)
    span.set_tag(ttags.CLIENT_ADDR, "{}:0".format(request.remote_ip))

    context = RequestContextManager(span)
    instance._tc_span = span
    span.__enter__()
    # never exit because we can not find an safe place to insert our exit.
    context.__enter__()
    return wrapped(*args, **kwargs)


def _wrapper_request_handler_finish(wrapped, instance, args, kwargs):
    try:
        return wrapped(*args, **kwargs)
    finally:
        if not hasattr(instance, '_tc_span'):
            # finish may be called while prepare is not called.
            # finish may be called twice
            return
        span = instance._tc_span
        del instance._tc_span
        status_code = int(instance.get_status())

        span.set_tag(ttags.HTTP_STATUS_CODE, status_code)
        if 500 <= status_code <= 599 and hasattr(instance, "_tc_exc_info"):
            typ, value, tb = instance._tc_exc_info
            span.__exit__(typ, value, tb)
        else:
            span.__exit__()
        RequestContextManager.clear()


def _wrapper_request_handler_log_exception(wrapped, instance, args, kwargs):
    def _arguments(typ, value, tb):
        return typ, value, tb
    typ, value, tb = _arguments(*args, **kwargs)
    rv = wrapped(*args, **kwargs)
    if isinstance(value, HTTPError) and not 500 <= value.status_code < 600:
        return rv

    # save exception so it can be recorded in handler.finish
    instance._tc_exc_info = (typ, value, tb)


def instrument_tornado_web(tornado):
    global HTTPError
    HTTPError = getattr(tornado, "HTTPError")

    wrap_function_wrapper(tornado, 'RequestHandler.__init__',
                          _wrapper_request_handler__init__)
    wrap_function_wrapper(tornado, 'RequestHandler.finish',
                          _wrapper_request_handler_finish)
    wrap_function_wrapper(tornado, 'RequestHandler.log_exception',
                          _wrapper_request_handler_log_exception)
