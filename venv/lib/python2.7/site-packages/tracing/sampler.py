#!/usr/bin/env python
# coding: utf-8

import logging
import random
import time

_logger = logging.getLogger(__name__)


class BaseSampler(object):
    salt = random.getrandbits(64)

    def __init__(self, sample_rate):
        self._sample_rate = sample_rate

    def record_span(self, operation_name, timestamp, is_success):
        pass

    def sample(self, operation_name, trace_id):
        return ((trace_id ^ self.__class__.salt) % 10000 <
                self._sample_rate * 10000)


class AdaptiveSampler(BaseSampler):
    """A sampler that increases sample rate when server span has error."""

    def __init__(self, sample_rate, error_threshold=10, sample_count=100):
        """
        If we have `error_threshold` errors in the last minute, we enter
        `always sample mode` where we sample the following 100 spans with the
        same operation_name in an attempt to catch the error. After that, we
        return to normal mode. This `always sample mode` can only happen
        once 5 minutes.
        """
        super(AdaptiveSampler, self).__init__(sample_rate)
        self._last_clear = time.time()
        # operation_name -> count, count will be cleared every 1 minutes.
        self._error = {}
        self._always_sampled = {}
        self._last_in_sampled_mode = {}
        self._error_threshold = error_threshold
        self._sample_count = sample_count

    def record_span(self, operation_name, timestamp, is_success):
        if self._sample_rate == 0 or self._sample_rate == 1:
            return
        if timestamp - self._last_clear > 60:
            self._error = {}
            next_clear = self._last_clear
            while next_clear < timestamp:
                next_clear += 60
            self._last_clear = next_clear
        if is_success:
            return
        count = self._error.setdefault(operation_name, 0) + 1
        self._error[operation_name] = count
        if count == self._error_threshold and operation_name not in self._always_sampled:
            last_sample_time = self._last_in_sampled_mode.get(
                operation_name, None)
            if last_sample_time is None or timestamp - last_sample_time > 300:
                _logger.info("{} error spans in 60 seconds, entering always "
                             "sampling mode".format(count))
                self._last_in_sampled_mode[operation_name] = timestamp
                self._always_sampled[operation_name] = self._sample_count

    def sample(self, operation_name, trace_id):
        if self._sample_rate == 0:
            return False
        if self._sample_rate == 1:
            return True
        if operation_name in self._always_sampled:
            self._always_sampled[operation_name] -= 1
            if self._always_sampled[operation_name] >= 0:
                return True
            del self._always_sampled[operation_name]
            _logger.info("Returning to normal sampling mode.")
        return super(AdaptiveSampler, self).sample(operation_name, trace_id)
