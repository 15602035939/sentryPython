#!/usr/bin/env python
# coding: utf-8

import struct
import logging

from thrift.protocol import TBinaryProtocol
from thrift.transport import TTransport

from tracing.gen_thrift.zipkinCore import ttypes
from tracing.statsd import Statsd

_logger = logging.getLogger(__name__)


class Codec(object):
    def encode(self, spans, stats_collection):
        """Encode spans into msgs"""
        pass

    def decode(self, msgs):
        """Decode msgs into spans"""
        pass


class ThriftCodec(Codec):
    """
    TODO:
    * 去除对 Statsd 的依赖, 例如, 通过提供 ScopedCollection 来去除对 unit name 的依赖
    * encode 不接收 stats_collection 参数, 这需要有统一的 stats_collection 发送方式
    """
    def __init__(self, max_spans_per_msg=5000, max_bytes_per_msg=1024*1024):
        self.max_spans_per_msg = max_spans_per_msg
        self.max_bytes_per_msg = max_bytes_per_msg

    def encode(self, spans, stats_collection):
        """do not put too much span in a msg."""
        msgs = []
        span_count = 0
        trans = TTransport.TMemoryBuffer()
        tbp = TBinaryProtocol.TBinaryProtocolAccelerated(trans)
        size = 0
        for span in spans:
            try:
                span.to_thrift().write(tbp)
            except OverflowError as e:
                _logger.exception("encode span to bytes failed: %s, span: %s", e, span)
            span_count += 1
            buf = trans.getvalue()
            stats_collection.timing("tracing.%s.sender.span_size" % Statsd.unit_name,
                                    (len(buf) - size) / 1000.0)
            size = len(buf)
            if len(buf) >= self.max_bytes_per_msg or span_count >= self.max_spans_per_msg:
                msg = struct.pack("!bi", 12, span_count) + buf
                msgs.append(msg)
                # release memory.
                trans.close()
                trans = TTransport.TMemoryBuffer()
                tbp = TBinaryProtocol.TBinaryProtocolAccelerated(trans)
                stats_collection.timing("tracing.%s.sender.span_count_per_msg" % Statsd.unit_name,
                                        span_count / 1000.0)
                span_count = 0
        if span_count > 0:
            msg = struct.pack("!bi", 12, span_count) + trans.getvalue()
            msgs.append(msg)
            trans.close()
            stats_collection.timing("tracing.%s.sender.span_count_per_msg" % Statsd.unit_name,
                                    span_count / 1000.0)

        return msgs

    def decode(self, msgs):
        """Decode msgs into thrift spans.

        Currently only used in test.
        """
        spans = []
        for msg in msgs:
            a, span_count = struct.unpack("!bi", msg[:5])
            assert a == 12
            trans = TTransport.TMemoryBuffer(msg[5:])
            tbp = TBinaryProtocol.TBinaryProtocolAccelerated(trans)
            while span_count > 0:
                span = ttypes.Span()
                span.read(tbp)
                spans.append(span)
                span_count -= 1
        return spans
