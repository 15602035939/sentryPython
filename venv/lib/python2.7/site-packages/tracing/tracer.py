#!/usr/bin/env python
# coding: utf-8

import opentracing
from opentracing.ext import tags as otags
from opentracing.propagation import UnsupportedFormatException, Format

from tracing.constants import HTTP_HEADER_TRACE_ID, HTTP_HEADER_SPAN_ID, \
    HTTP_HEADER_PARENT_ID, HTTP_HEADER_SAMPLED
from tracing.span import Span
from tracing.statsd import Statsd
from tracing.traceid import TraceId
from tracing.util import rand64bit, rand128bit


class NoopTracer(opentracing.Tracer):
    def __init__(self, *_, **__):  # ignore all args
        super(NoopTracer, self).__init__()


class ZipkinTracer(opentracing.Tracer):

    # Binary is not supported currently
    _supported_formats = [Format.TEXT_MAP]

    def __init__(self, unit_name, version, sampler, sender, max_buf_span=1000):
        super(ZipkinTracer, self).__init__()

        self._version = version
        self._sender = sender
        self._unit_name = unit_name
        self._sampler = sampler
        self._spans = []
        self._max_buf_span = max_buf_span

    def start_span(self, operation_name=None, parent=None, tags=None,
                   start_time=None):
        """Starts and returns a new Span representing a unit of work.
        :param tags: Dictionary of Span Tags. Must specify the following tags
          opentracing.ext.tags.SPAN_KIND
        """

        if tags is None or otags.SPAN_KIND not in tags:
            raise ValueError("must specify span kind in tags")

        if parent is not None:
            trace_id = TraceId(trace_id=parent.trace_id.trace_id,
                               parent_id=parent.trace_id.span_id,
                               span_id=rand64bit(),
                               sampled=parent.trace_id.sampled)
        else:
            trace_id_number = rand128bit()
            trace_id = TraceId(
                trace_id=trace_id_number, parent_id=None,
                span_id=rand64bit(),
                sampled=self._sampler.sample(operation_name, trace_id_number))

        span = Span(self._unit_name, self._version, operation_name, parent,
                    tags, start_time, trace_id, self)
        return span

    def inject(self, span, format, carrier):
        if format not in self._supported_formats:
            raise UnsupportedFormatException(format)
        trace_id = getattr(span, 'trace_id', None)
        if trace_id is None:
            return
        carrier.update({
            HTTP_HEADER_TRACE_ID: "%x" % trace_id.trace_id,
            HTTP_HEADER_SPAN_ID: "%x" % trace_id.span_id,
        })
        if trace_id.sampled is not None:
            carrier[HTTP_HEADER_SAMPLED] = str(int(trace_id.sampled))
        if trace_id.parent_id is not None:
            carrier[HTTP_HEADER_PARENT_ID] = "%x" % trace_id.parent_id

    def join(self, operation_name, format, carrier):
        if format not in self._supported_formats:
            raise UnsupportedFormatException(format)

        if HTTP_HEADER_TRACE_ID not in carrier or \
                HTTP_HEADER_SPAN_ID not in carrier:
            return None
        try:
            trace_id = int(carrier.get(HTTP_HEADER_TRACE_ID), 16)
            span_id = int(carrier.get(HTTP_HEADER_SPAN_ID), 16)
            parent_id = int(carrier.get(HTTP_HEADER_PARENT_ID), 16)
            sampled = bool(int(carrier.get(HTTP_HEADER_SAMPLED, True)))
        except (ValueError, TypeError):
            return None

        trace_id = TraceId(trace_id=trace_id, parent_id=parent_id,
                           span_id=span_id, sampled=sampled)

        tags = {
            otags.SPAN_KIND: otags.SPAN_KIND_RPC_SERVER,
        }
        span = Span(self._unit_name, self._version, operation_name, None, tags,
                    None, trace_id, self)
        return span

    def flush(self):
        # called in reporter thread, send and wait for IO complete
        Statsd.send_stats(Span.stats_collection)
        self._sender.flush()

    def end(self, span):
        if span.is_server:
            self._sampler.record_span(span.name, span.start_time,
                                      span.is_success)
        if span._is_active_sampling:
            self._spans.append(span)
            self._maybe_write(span.is_server)

    def _maybe_write(self, is_server):
        if len(self._spans) > self._max_buf_span or is_server:
            # ready to be sent
            self._sender.write(self._spans)
            self._spans = []
