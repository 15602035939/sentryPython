#!/usr/bin/env python
# coding: utf-8

import os
from functools import wraps
import socket
import time
import logging
import random

# 最大连续失败次数
SEQ_FAIL_NUMBER_LIMIT = 8
# UDP 检测发送成功次数
SEQ_CONN_VALID_NUMBER = 2
# 如果在 SEQ_FAIL_NUMBER_LIMIT 次数都尝试失败，下轮重置 dns_seq_fail_number, 设置为该参数
REPEAT_SEQ_FAIL_NUMBER = 3
# 防止后端挂掉后，客户端同时请求，造成 DDos 攻击，增加随机请求时间, 单位是秒
RANDOM_BASE = {"start": 0, "end": 20}


class StatsdClient(object):
    """
    StatsCollection collects all metrics.
    """
    def __init__(self):
        self.app_name = None
        self._no_send = False
        self._socket = None

    def initialize(self, app_name, host="status", port=8126):
        self.host = host
        self.port = port
        # 在 socket.getaddrinfo 和 socket.socket 时 gevent 可能切走，请小心竞态条件
        self.dns_resolver()
        self._socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self._socket.connect(self._addr)
        logging.info("Statsd initialized with app_name {}".format(app_name))
        self.app_name = app_name
        self._no_send = False
        self.dns_seq_fail_number = 0
        self.dns_seq_fail_number_limit = SEQ_FAIL_NUMBER_LIMIT
        self.start_stop_dns_ts = 0
        self.address_valid = True
        self.check_conn_valid = 0
        self.seq_conn_valid_number = SEQ_CONN_VALID_NUMBER
        self._random_base = random.randint(RANDOM_BASE["start"], RANDOM_BASE["end"])

    def frozen_time(self):
        return 2 ** self.dns_seq_fail_number - 1 + self._random_base

    def stop_dns_resolve(self):
        if int(time.time()) - self.start_stop_dns_ts < self.frozen_time():
            return True
        return False

    def dns_resolver(self):
        family, _, _, _, self._addr = socket.getaddrinfo(
            self.host, self.port, socket.AF_INET, socket.SOCK_DGRAM)[0]
        self._socket = None
        logging.info('dns resolve at: {}, get brubeck ip {}'.format(time.ctime(), self._addr))

    def send(self, name, value, mtype):
        if not self.app_name:
            app_name = os.environ.get('ZHIHU_APP_NAME')
            if not app_name:
                logging.info("Failed to initialize Statsd, and environment `ZHIHU_APP_NAME` not set")
                self._no_send = True
                return
            self.initialize(app_name)
        if self._no_send:
            return
        # 如果dns解析失败后，为防止出现dns解析ddos，此处采用指数退让时间策略，此处即连续解析失败次数为dns_seq_fail_number
        # 那么，在2^dns_seq_fail_number的秒内禁止重新解析，超过此时间后，重新进入下一个解析周期
        # 当使用check_conn_valid认定解析结果可用后，dns_seq_fail_number从0开始重新计数
        if not self.address_valid:
            if self.stop_dns_resolve():
                return
            else:
                # 解析失败后，使用的后端地址也失效，dns解析解禁后，需要重新解析获得一个新地址
                self.dns_resolver()
                self.address_valid = True

        # 因为udp的connection是否有效需要连续seq_conn_valid_number次发送成功才能检测出来，所以此处加了一个计数，
        # 如果连续seq_conn_valid_number次发送成功, 则dns_seq_fail_number重新计数
        if self.check_conn_valid >= self.seq_conn_valid_number:
            self.dns_seq_fail_number = 0
            self.check_conn_valid = self.seq_conn_valid_number

        if mtype == "g":
            format_str = "%s.%s:%.3f|%s"
        else:
            format_str = "%s.%s:%d|%s"
        msg = format_str % (self.app_name, name, value, mtype)
        try:
            if self._socket is None:
                self._socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                self._socket.connect(self._addr)
            self._socket.send(msg)
            self.check_conn_valid += 1
        except socket.error:
            self.check_conn_valid = 0
            self._socket.close()
            if self.dns_seq_fail_number > self.dns_seq_fail_number_limit:
                self.dns_seq_fail_number = REPEAT_SEQ_FAIL_NUMBER
            self.dns_seq_fail_number += 1
            self.address_valid = False
            self.start_stop_dns_ts = int(time.time())
            logging.warning(
                "addreess error happend {} and happened {} times, "
                "should wait for {}s to resolve dns, happened at {}".format(
                    self._addr,
                    self.dns_seq_fail_number,
                    self.frozen_time(),
                    time.ctime())
            )

    def incr(self, name, count=1):
        self.send(name, count, "c")

    def gauge(self, name, value):
        self.send(name, value, "g")

    def timing(self, name, value):
        """
        :param value: time in seconds, as returned by time.time()

        3.1234 will be sent to graphite as 3123 ms
        """
        value = int(value * 1000)
        self.send(name, value, "ms")

    def time(self, name):
        """Time a block of code or function, and observe the duration in milliseconds.
        Can be used as a function decorator or context manager.
        """

        return Timer(self, name)


class Timer(object):
    def __init__(self, client, name):
        self._client = client
        self._name = name

    def __enter__(self):
        self._start = time.time()

    def __exit__(self, typ, value, traceback):
        # Time can go backwards.
        self._client.timing(self._name, max(time.time() - self._start, 0))

    def __call__(self, f):
        @wraps(f)
        def wrapped(*args, **kwargs):
            with self:
                return f(*args, **kwargs)
        return wrapped


Statsd = StatsdClient()
